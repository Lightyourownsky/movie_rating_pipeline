# Simple Movie Data Pipeline - tsworks Assignment

## Project Overview
This project is a foundational data pipeline designed for a movie analytics startup. It automates the process of ingesting movie and rating data from the MovieLens dataset, enriches it with detailed metadata (Director, Plot, Box Office, etc.) from the OMDb API, and stores it in a structured, optimized SQLite database for analysis.

## Project Structure
- `etl.py`: The core Python script containing extraction, transformation, and loading logic.
- `schema.sql`: SQL script defining the relational database tables, constraints, and indexes.
- `queries.sql`: SQL script to answer specific analytical business questions.
- `movie_database.db`: The final SQLite database generated by the pipeline.

## Environment Setup & Usage

### 1. Prerequisites
- Python 3.x
- An OMDb API Key (Already configured in the script as `ae55002f`)

### 2. Installation
Install the necessary libraries using pip:
```bash
pip install pandas sqlalchemy requests
```
### 3. Running the pipeline

Place movies.csv and ratings.csv in the project root directory and run:
```bash
python etl.py
```

## Data Model & Design Choices

Relational Structure: I designed a normalized schema to minimize redundancy.

Many-to-Many Relationship: Since movies often belong to multiple genres, I implemented a movie_genres junction table. This allows for cleaner and more accurate genre-based analytics.

Data Integrity: Used CHECK constraints to ensure ratings fall within a valid range. Used ON DELETE CASCADE to maintain referential integrity.

Performance: Added indexes on movieId and userId columns to speed up JOIN operations and aggregations in the analytical queries.

## Challenges & Problem Solving

API Rate Limiting: To avoid being blocked by the OMDb API, I implemented a time.sleep() delay between requests and limited the enrichment to the first 100 movies for the initial run.

Data Gaps: Some movies returned "N/A" for directors or plot details. I handled this by sanitizing the input in the SQL queries (filtering out "N/A" strings) to ensure analytical reports remained accurate.

Title Formatting: MovieLens titles often include the year in parentheses (e.g., "Toy Story (1995)"). I used Regular Expressions (Regex) to extract the year and clean the title string to ensure higher match rates with the OMDb API.

## Potential Improvements & Scaling

In a real-world production environment:

Database: Migrate from SQLite to PostgreSQL or a cloud warehouse like Snowflake for better scalability.

Orchestration: Use Apache Airflow to schedule and monitor the pipeline steps.

Efficiency: Use the asyncio and httpx libraries in Python to perform API calls concurrently, significantly reducing the total execution time for larger datasets.
